---
title: "Exercices R"
output: html_document
author: "Ziyade CHABI MACO"

date: "2024-12-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

#Python part
#Link1: Exercise 1:first 5 rows from COVID-19 dataset, printing the dataset information and check the missing values.
```{r print}

# Charger les bibliothèques nécessaires
library(dplyr)
library(readr)

# Charger les données à partir du fichier CSV en ligne
covid_data <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv")

# Afficher les premières lignes des données
print("Dataset:")
print(head(covid_data))

# Afficher les informations sur le dataset
cat("\nDataset information:\n")
glimpse(covid_data)

# Informations sur les données manquantes
cat("\nMissing data information:\n")
missing_data <- colSums(is.na(covid_data))
print(missing_data)

```

#Python part
#Link1: Exercise 2:Getting the latest number of confirmed, deaths, recovered and active cases of Novel Coronavirus (COVID-19) Country wise.
```{r print}

# Load necessary library
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv"
covid_data <- read.csv(url)

# Calculate the 'Active' cases
covid_data$Active <- covid_data$Confirmed - covid_data$Deaths - covid_data$Recovered

# Group by 'Country/Region' and summarize the data
result <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE),
    Active = sum(Active, na.rm = TRUE)
  )

# Print the result
print(result)

```

#Python part
#Link1: Exercise 3:Getting the latest number of confirmed, deaths, recovered and active cases of Novel Coronavirus (COVID-19) Country wise.
```{r print}
# Load necessary libraries
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-16-2020.csv"
covid_data <- read.csv(url)

# Group by 'Country/Region' and 'Province/State' and take the maximum of 'Confirmed', 'Deaths', and 'Recovered'
data <- covid_data %>%
  group_by(Country.Region, Province.State) %>%
  summarise(
    Confirmed = max(Confirmed, na.rm = TRUE),
    Deaths = max(Deaths, na.rm = TRUE),
    Recovered = max(Recovered, na.rm = TRUE)
  )

# Print all rows (to avoid truncation, similar to `pd.set_option('display.max_rows', None)` in Python)
print(data, n = Inf)


```

#Python part
#Link1: Exercise 4:Getting the Chinese province wise cases of confirmed, deaths and recovered cases of Novel Coronavirus (COVID-19).
```{r print}
# Load necessary libraries
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv"
covid_data <- read.csv(url)

# Group by 'Country/Region' and calculate the sum of 'Confirmed', 'Deaths', and 'Recovered'
data <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE)
  )

# Filter rows where 'Confirmed' equals 'Deaths'
result <- data %>%
  filter(Confirmed == Deaths) %>%
  select(Country.Region, Confirmed, Deaths)

# Sort by 'Confirmed' in descending order
result <- result %>%
  arrange(desc(Confirmed))

# Keep rows where 'Confirmed' > 0 and reset the row index
result <- result %>%
  filter(Confirmed > 0) %>%
  mutate(Row = row_number()) %>% # Adds a row index
  select(-Row)                  # Optional: drop the row index column

# Print the result
print(result)


```

#Python part
#Link1: Exercise 5:Getting the latest country wise deaths cases of Novel Coronavirus (COVID-19).
```{r print}
# Load necessary libraries
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv"
covid_data <- read.csv(url)

# Group by 'Country/Region' and calculate the sum of 'Confirmed', 'Deaths', and 'Recovered'
data <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE)
  )

# Filter rows where Deaths > 0 and select 'Country/Region' and 'Deaths'
result <- data %>%
  filter(Deaths > 0) %>%
  select(Country.Region, Deaths)

# Print the result
print(result)


```

#Python part
#Link1: Exercise 6:listing countries with no cases of Novel Coronavirus (COVID-19) recovered.
```{r print}
# Load necessary libraries
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv"
covid_data <- read.csv(url)

# Group by 'Country/Region' and calculate the sum of 'Confirmed', 'Deaths', and 'Recovered'
data <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE)
  )

# Filter rows where 'Recovered' is 0 and select relevant columns
result <- data %>%
  filter(Recovered == 0) %>%
  select(Country.Region, Confirmed, Deaths, Recovered)

# Print the result
print(result)

```

#Python part
#Link1: Exercise 7:listing countries with all cases of Novel Coronavirus (COVID-19) died.
```{r print}
# Charger les bibliothèques nécessaires
library(dplyr)
library(readr)

# Charger les données à partir du fichier CSV en ligne
covid_data <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv")

# Grouper les données par 'Country/Region' et calculer les sommes pour 'Confirmed', 'Deaths' et 'Recovered'
data <- covid_data %>%
  group_by(`Country/Region`) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE)
  )

# Filtrer les pays où Confirmed == Deaths
result <- data %>%
  filter(Confirmed == Deaths) %>%
  select(`Country/Region`, Confirmed, Deaths)

# Trier les résultats par Confirmed dans l'ordre décroissant
result <- result %>%
  arrange(desc(Confirmed))

# Filtrer les pays avec un nombre de cas Confirmed > 0
result <- result %>%
  filter(Confirmed > 0)

# Réinitialiser les index
result <- result %>%
  mutate(row_id = row_number()) %>%
  select(-row_id)

# Afficher les résultats finaux
print(result)


```

#Python part
#Link1: Exercise 8:listing countries with all cases of Novel Coronavirus (COVID-19) recovered.
```{r print}
# Load necessary libraries
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv"
covid_data <- read.csv(url)

# Group by 'Country/Region' and calculate the sum of 'Confirmed', 'Deaths', and 'Recovered'
data <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE)
  )

# Filter rows where 'Confirmed' equals 'Recovered'
result <- data %>%
  filter(Confirmed == Recovered) %>%
  select(Country.Region, Confirmed, Recovered)

# Sort by 'Confirmed' in descending order
result <- result %>%
  arrange(desc(Confirmed))

# Keep rows where 'Confirmed' > 0 and reset the row index
result <- result %>%
  filter(Confirmed > 0)

# Print the result
print(result)


```

#Python part
#Link1: Exercise 9:Getting the top 10 countries data (Last Update, Country/Region, Confirmed, Deaths, Recovered) of Novel Coronavirus (COVID-19).


```{r print}

# Load necessary libraries
library(dplyr)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-18-2020.csv"
covid_data <- read.csv(url)

# Select only relevant columns
covid_data <- covid_data %>%
  select(Last.Update, Country.Region, Confirmed, Deaths, Recovered)

# Group by 'Country/Region', find the maximum value for each group, and sort by 'Confirmed' in descending order
result <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Last.Update = max(Last.Update, na.rm = TRUE),
    Confirmed = max(Confirmed, na.rm = TRUE),
    Deaths = max(Deaths, na.rm = TRUE),
    Recovered = max(Recovered, na.rm = TRUE)
  ) %>%
  arrange(desc(Confirmed)) %>%
  slice(1:10)  # Get the top 10 rows

# Print the result
print(result)

```

#Python part
#Link1: Exercise 10:create a plot (lines) of total deaths, confirmed, recovered and active cases Country wise where deaths greater than 150.
```{r print}
# Load necessary libraries
library(dplyr)
library(ggplot2)

# Read the CSV file directly from the URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-19-2020.csv"
covid_data <- read.csv(url)

# Select only the relevant columns
covid_data <- covid_data %>%
  select(Last.Update, Country.Region, Confirmed, Deaths, Recovered)

# Create the 'Active' column
covid_data <- covid_data %>%
  mutate(Active = Confirmed - Deaths - Recovered)

# Group by 'Country/Region' and calculate the sum of relevant columns
r_data <- covid_data %>%
  group_by(Country.Region) %>%
  summarise(
    Deaths = sum(Deaths, na.rm = TRUE),
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE),
    Active = sum(Active, na.rm = TRUE)
  )

# Filter countries with more than 50 deaths
r_data <- r_data %>%
  filter(Deaths > 150) %>%
  arrange(desc(Deaths))

# Plot the data
ggplot(r_data, aes(x = Country.Region)) +
  geom_line(aes(y = Deaths, color = "Deaths"), group = 1) +
  geom_line(aes(y = Confirmed, color = "Confirmed"), group = 1) +
  geom_line(aes(y = Recovered, color = "Recovered"), group = 1) +
  geom_line(aes(y = Active, color = "Active"), group = 1) +
  labs(
    title = "Total Deaths (>150), Confirmed, Recovered, and Active Cases by Country",
    x = "Country",
    y = "Number of Cases"
  ) +
  scale_color_manual(
    name = "Legend",
    values = c("Deaths" = "red", "Confirmed" = "green", "Recovered" = "blue", "Active" = "black")
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5)
  )

```

#Python part
#Link1: Exercise 11:visualize the state/province wise death cases of Novel Coronavirus (COVID-19) in USA.
```{r print}
# Load necessary libraries
library(dplyr)
library(plotly)

# Read the COVID-19 data from the provided URL
url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-17-2020.csv"
covid_data <- read.csv(url)

# Filter data for the US and drop unnecessary columns
us_data <- covid_data %>%
  filter(Country.Region == "US") %>%
  select(-Country.Region, -Latitude, -Longitude)

# Remove rows where all numeric values are zero
us_data <- us_data %>%
  filter(rowSums(across(where(is.numeric), ~ .x), na.rm = TRUE) > 0)

# Group by 'Province/State' and sum 'Deaths'
us_data <- us_data %>%
  group_by(Province.State) %>%
  summarise(Deaths = sum(Deaths, na.rm = TRUE))

# Filter states with more than 0 deaths
us_data_death <- us_data %>%
  filter(Deaths > 0)

# Create a bar plot using plotly
state_fig <- plot_ly(
  data = us_data_death,
  x = ~Province.State,
  y = ~Deaths,
  type = "bar",
  text = ~Deaths,
  textposition = "outside",
  marker = list(color = "red")
) %>%
  layout(
    title = "State-wise Deaths Reported of COVID-19 in USA",
    xaxis = list(title = "Province/State"),
    yaxis = list(title = "Number of Deaths"),
    showlegend = FALSE
  )

# Show the plot
state_fig

```

#Python part
#Link1: Exercise 12:visualize the state/province wise Active cases of Novel Coronavirus (COVID-19) in USA.
```{r print}
# Charger les bibliothèques nécessaires
library(dplyr)
library(readr)
library(ggplot2)

# Charger les données à partir du fichier CSV en ligne
covid_data <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-18-2020.csv")

# Ajouter une colonne 'Active' calculée
covid_data <- covid_data %>%
  mutate(Active = Confirmed - Deaths - Recovered)

# Filtrer les données pour les États-Unis et supprimer des colonnes inutiles
us_data <- covid_data %>%
  filter(`Country/Region` == "US") %>%
  select(-`Country/Region`, -Latitude, -Longitude)

# Supprimer les lignes avec une somme des valeurs <= 0
us_data <- us_data[rowSums(select_if(us_data,is.numeric), na.rm = TRUE) > 0, ]

# Grouper par 'Province/State' et sommer les cas 'Active'
us_data <- us_data %>%
  group_by(`Province/State`) %>%
  summarise(Active = sum(Active, na.rm = TRUE))

# Filtrer les états avec des cas 'Active' > 0
us_data_death <- us_data %>%
  filter(Active > 0)

# Créer un graphique à barres avec ggplot2
state_fig <- ggplot(us_data_death, aes(x = reorder(`Province/State`, -Active), y = Active, label = Active)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(vjust = -0.5, color = "black") +
  labs(
    title = "State wise recovery cases of COVID-19 in USA",
    x = "Province/State",
    y = "Active Cases"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Afficher le graphique
print(state_fig)

```

#Python part
#Link1: Exercise 13:Visualize the state/province wise combine number of confirmed, deaths, recovered, active Novel Coronavirus (COVID-19) cases in USA.
```{r print}
# Charger les bibliothèques nécessaires
library(dplyr)
library(readr)
library(tidyr)
library(ggplot2)

# Charger les données à partir du fichier CSV en ligne
covid_data <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-19-2020.csv")

# Ajouter une colonne 'Active' calculée
covid_data <- covid_data %>%
  mutate(Active = Confirmed - Deaths - Recovered)

# Filtrer les données pour les États-Unis et supprimer les colonnes inutiles
combine_us_data <- covid_data %>%
  filter(`Country/Region` == "US") %>%
  select(-`Country/Region`, -Latitude, -Longitude)

# Supprimer les lignes avec une somme des valeurs <= 0
combine_us_data <- combine_us_data %>%
  filter(rowSums(select_if(., is.numeric), na.rm = TRUE) > 0)

# Grouper par 'Province/State' et sommer les colonnes numériques
combine_us_data <- combine_us_data %>%
  group_by(`Province/State`) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE),
    Recovered = sum(Recovered, na.rm = TRUE),
    Active = sum(Active, na.rm = TRUE)
  )

# Transformer les données en format long
combine_us_data_long <- combine_us_data %>%
  pivot_longer(
    cols = c(Confirmed, Deaths, Recovered, Active),
    names_to = "Case",
    values_to = "Count"
  )

# Créer un graphique à barres avec ggplot2
fig <- ggplot(combine_us_data_long, aes(x = reorder(`Province/State`, -Count), y = Count, fill = Case, label = Count)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(position = position_dodge(width = 0.9), vjust = -0.5, size = 3) +
  labs(
    title = "USA State wise combine number of confirmed, deaths, recovered, active COVID-19 cases",
    x = "Province/State",
    y = "Count"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Afficher le graphique
print(fig)

```

#Python part
#Link1: Exercise 14:visualize Worldwide Confirmed Novel Coronavirus (COVID-19) cases over time.
```{r print}
# Charger les bibliothèques nécessaires
library(dplyr)
library(readr)
library(ggplot2)

# Charger les données à partir du fichier CSV en ligne
covid_data <- read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/03-19-2020.csv")

# Grouper les données par 'Last Update' et sommer 'Confirmed' et 'Deaths'
grouped <- covid_data %>%
  group_by(`Last Update`) %>%
  summarise(
    Confirmed = sum(Confirmed, na.rm = TRUE),
    Deaths = sum(Deaths, na.rm = TRUE)
  )

# Créer un graphique de ligne pour les cas confirmés dans le temps
fig <- ggplot(grouped, aes(x = as.POSIXct(`Last Update`, format = "%Y-%m-%d %H:%M:%S"), y = Confirmed)) +
  geom_line(color = "steelblue", size = 1) +
  labs(
    title = "Worldwide Confirmed Novel Coronavirus (COVID-19) Cases Over Time",
    x = "Last Update",
    y = "Confirmed Cases"
  ) +
  theme_minimal()

# Afficher le graphique
print(fig)

```

#Link2: Exercise 
```{r print}
#Link2: Exercise 1
# TODO: read each row from a given csv file and print a list of strings.
# Load the CSV file
data <- read.csv("C:/Users/ziyad/Documents/Python_Learning/Python_andR/Python/base3.csv", stringsAsFactors = FALSE)

# Print each row
apply(data, 1, function(row) {
  print(paste(row, collapse = ", "))
})
```


```{r print}
#Link3: Exercise 1:Get the columns of the DataFrame
df <- read.csv("C:/Users/ziyad/Documents/Python_Learning/Python_andR/Rapplying/movies_metadata.csv", stringsAsFactors = FALSE)

# Print the column names
cat("Columns of the DataFrame:\n")
print(colnames(df))
```


```{r print}
##Link3: Exercise 2:  get the information of the DataFrame (movies_metadata.csv file)including data types and memory usage

# Charger les bibliothèques nécessaires
library(readr)
library(dplyr)

# Lire le fichier CSV
df <- read_csv("movies_metadata.csv", col_types = cols(.default = "c"))
problems(df)
# Afficher les détails du DataFrame
cat("Details of the DataFrame:\n")
glimpse(df)
# glimpse fournit une vue d'ensemble du Dataframe like df.info()

```


```{r print}
##Link3: Exercise 3
df <- read.csv("C:/Users/ziyad/Documents/Python_Learning/Python_andR/Rapplying/movies_metadata.csv", stringsAsFactors = FALSE)

# Get the details of the third movie
third_movie <- df[3, ]
cat("Details of the third movie:\n")
print(third_movie)
```


```{r print}
##Link3: Exercise 4:Count the number of rows and columns of the DataFrame
df <- read.csv("C:/Users/ziyad/Documents/Python_Learning/Python_andR/Rapplying/movies_metadata.csv", stringsAsFactors = FALSE)

# Get the dimensions of the DataFrame
result <- dim(df)
cat("Number of rows and columns of the DataFrame:\n")
print(result)

```


```{r print}
##Link3: Exercise 5:Get the details of the columns title and genres of the DataFrame.
# Charger les données à partir du fichier CSV
df <- read.csv("movies_metadata.csv")

# Extraire les colonnes "title" et "genres"
result <- df[, c("title", "genres")]

# Afficher les résultats
cat("Details of title and genres:\n")
print(result)


```


```{r print}
##Link3: Exercise 6: get the details of the movie with title 'Grumpier Old Men'.
df <- read.csv("movies_metadata.csv", stringsAsFactors = FALSE)

# Définir "title" comme index (en R, cela équivaut à le convertir en rownames)
rownames(df) <- df$title

# Récupérer les détails du film "Grumpier Old Men"
result <- df["Grumpier Old Men", ]

# Afficher les résultats
cat("Details of the movie 'Grumpier Old Men':\n")
print(result)

```


```{r print}
## Link3: Exercise 7: Get the details of  fifth movie of the DataFrame.
df <- read.csv("movies_metadata.csv", stringsAsFactors = FALSE)

# Récupérer les détails du cinquième film
result <- df[5, ]

# Afficher les résultats
cat("Details of the fifth movie of the DataFrame:\n")
print(result)

```


```{r print}
## Link3: Exercise 8: 

df <- read.csv("movies_metadata.csv", stringsAsFactors = FALSE)

small_df <- df[, c("title", "release_date", "budget", "revenue", "runtime")]

# Afficher les premières lignes du DataFrame plus petit
cat("Smaller DataFrame:\n")
head(small_df)


```


```{r print}
## Link3: Exercise 9: displaying the first 10 rows of the DataFrame.

# Charger les données à partir du fichier CSV
df <- read.csv('movies_metadata.csv', stringsAsFactors = FALSE)

# Afficher les 10 premières lignes du DataFrame
cat("First 10 rows of the DataFrame:\n")
head(df, 10)


```


```{r print}
## Link3: Exercise 10:Sorting the DataFrame based on release_date 
df <- read.csv('movies_metadata.csv', stringsAsFactors = FALSE)

# Créer un DataFrame plus petit
small_df <- df[, c('title', 'release_date', 'budget', 'revenue', 'runtime')]

# Trier le DataFrame par 'release_date'
result <- small_df[order(as.Date(small_df$release_date, format = "%Y-%m-%d")), ]

# Afficher le DataFrame trié par date de sortie
cat("DataFrame based on release date.\n")
print(result)


```


```{r print}
## Link3: Exercise 11: Access those movies,released after 1995-01-01.
# Charger les données à partir du fichier CSV
df <- read.csv('movies_metadata.csv', stringsAsFactors = FALSE)

# Créer un DataFrame plus petit
small_df <- df[, c('title', 'release_date', 'budget', 'revenue', 'runtime')]

# Trier le DataFrame par 'release_date'
result <- small_df[order(as.Date(small_df$release_date, format = "%Y-%m-%d")), ]

# Afficher le DataFrame trié par date de sortie
cat("DataFrame based on release date.\n")
print(result)

```



```{r sort_runtime}
## Link3: Exercise 12:Sort movies on runtime in descending order
# Charger les bibliothèques nécessaires
library(readr)

# Lire le fichier CSV
df <- read_csv("movies_metadata.csv")

# Créer un sous-ensemble du DataFrame
small_df <- df[, c("title", "release_date", "budget", "revenue", "runtime")]

# Trier les films par durée (runtime) dans l'ordre décroissant
result <- small_df[order(-small_df$runtime), ]

# Afficher les 5 premières lignes du DataFrame trié
print("DataFrame sorted on Runtime.")
head(result)


```


```{r sort_runtime}
## Link3: Exercise 13: Get those movies whose revenue more than 2 million and spent less than 1 million
# Charger les bibliothèques nécessaires
library(readr)

# Lire le fichier CSV
df <- read_csv("movies_metadata.csv")

# Créer un sous-ensemble du DataFrame
small_df <- df[, c("title", "release_date", "budget", "revenue", "runtime")]

# Trier les films par durée (runtime) dans l'ordre décroissant
result <- small_df[order(-small_df$runtime), ]

# Afficher les 5 premières lignes du DataFrame trié
print("DataFrame sorted on Runtime.")
head(result)


```



```{r sort_runtime}
## Link3: Exercise 14:Get the longest runtime and shortest runtime.

# Charger la bibliothèque nécessaire
library(readr)

# Lire le fichier CSV
df <- read_csv("movies_metadata.csv")

# Créer un sous-ensemble du DataFrame avec les colonnes 'title' et 'runtime'
small_df <- df[, c("title", "runtime")]

# Afficher le sous-ensemble
print(small_df)

# Afficher la plus grande et la plus petite durée de film
cat("===============================================\n")
cat("Longest runtime\n")
print(max(small_df$runtime, na.rm = TRUE))  # Utilisation de na.rm = TRUE pour ignorer les NA
cat("Shortest runtime\n")
print(min(small_df$runtime, na.rm = TRUE))


```



```{r sort_runtime}
## Link3: Exercise 15:
# Charger la bibliothèque nécessaire
library(readr)

# Lire le fichier CSV
df <- read_csv("movies_metadata.csv")

# Calculer le 70e percentile de la colonne 'vote_count'
result <- quantile(df$vote_count, 0.70, na.rm = TRUE)

# Afficher le résultat
print(result)

```



```{r sort_runtime}
## Link3: Exercise 16: Movies longer than 30 minutes and shorter than 360 minutes
# Charger la bibliothèque nécessaire
library(readr)

# Lire le fichier CSV
df <- read_csv("movies_metadata.csv")

# Sélectionner les colonnes 'title' et 'runtime'
small_df <- df[, c("title", "runtime")]

# Filtrer les films dont la durée est entre 30 et 360 minutes
result <- small_df[small_df$runtime >= 30 & small_df$runtime <= 360, ]

# Afficher le résultat
print("List of movies longer than 30 minutes and shorter than 360 minutes:")
print(result)

```



```{r sort_runtime}
## Link3: Exercise 17: Displaying the movies (title, number of votes) that received specified number of votes
# Charger la bibliothèque nécessaire
library(readr)

# Lire le fichier CSV
df <- read_csv('movies_metadata.csv')

# Définir le nombre minimal de votes
n <- 500

# Créer un sous-ensemble de données avec les colonnes 'title' et 'vote_count'
small_df <- df[, c("title", "vote_count")]

# Filtrer les lignes avec un nombre de votes supérieur ou égal à n
result <- small_df[small_df$vote_count >= n, ]

# Afficher le résultat
cat("List of movies longer than 30 minutes and shorter than 360 minutes:\n")
print(result)
```

R prog.exercise
```{r sort_runtime}
# link1: R exercise
# Exercise 1: Dataframe showing
Id <- rep(1:4, each = 3)
Letter <- rep(letters[1:3], times = 4)
x <- seq(1, 43, along.with = Id)
y <- seq(-20, 0, along.with = Id)
df <- data.frame(Id, Letter, x, y)
df


```


```{r sort_runtime}
## link1: R exercise
# Exercise2: Adding  x.a,x.b,y.a,y.b
x <- seq(1, 43, along.with = Id)
y <- seq(-20, 0, along.with = Id)
df_wide <- reshape(df, idvar = "Id", timevar = "Letter", direction = "wide")
df_wide


```


```{r sort_runtime}
## link1: R exercise
# Exercise3: Two dataframe creating
df1 <- data.frame(Id = 1:4, Age = c(14, 12, 15, 10))
df2 <- data.frame(Id = 1:4, Sex = c("F", "M", "M", "F"), Code = letters[1:4])
M <- merge(df1, df2, by = "Id")
M


```


```{r sort_runtime}
# link1: R exercise
# Exercise 4: Adding 
df1 <- data.frame(Id = 1:4, Age = c(14, 12, 15, 10))
df2 <- data.frame(Id = 1:4, Sex = c("F", "M", "M", "F"), Code = letters[1:4])
M <- merge(df1, df2, by = "Id")
df3 <- data.frame(id2 = 4:1, score = c(100, 98, 94, 99))
N <- merge(M, df3, by.x = "Id", by.y = "id2")
N


```


```{r sort_runtime}
# link1: R exercise
# Exercise 5: Reduce and create a new dataframe
#1.
N_reduced <- N[, !(names(N) %in% c("Sex", "Code"))]
N_reduced

#2. Creating
values <- unlist(N_reduced)
ind <- rep(names(N_reduced), each = nrow(N_reduced))
df_new <- data.frame(values, ind)
df_new


```


```{r trees}
## link1: R exercise
# Exercise 6: Dataset trees

library(dplyr)

#a) Ensure trees is a data frame:
data("trees")
trees <- as.data.frame(trees)
print(class(trees))
trees
```
```{r trees}
#b) Create a new data frame A:
A <- data.frame(
  Girth = c(mean(trees$Girth), min(trees$Girth), max(trees$Girth), sum(trees$Girth)),
  Height = c(mean(trees$Height), min(trees$Height), max(trees$Height), sum(trees$Height)),
  Volume = c(mean(trees$Volume), min(trees$Volume), max(trees$Volume), sum(trees$Volume)),
  row.names = c("mean_tree", "min_tree", "max_tree", "sum_tree")
)
A

```


```{r order cols}
## link1: R exercise
# Exercise 7: Ordering cols
# Charger la bibliothèque dplyr
library(dplyr)
A <- data.frame(
  Girth = c(mean(trees$Girth), min(trees$Girth), max(trees$Girth), sum(trees$Girth)),
  Height = c(mean(trees$Height), min(trees$Height), max(trees$Height), sum(trees$Height)),
  Volume = c(mean(trees$Volume), min(trees$Volume), max(trees$Volume), sum(trees$Volume)),
  row.names = c("mean_tree", "min_tree", "max_tree", "sum_tree")
)
# 1) Trier le data frame par la première colonne (Girth)
A_ordered <- A %>%
  arrange(Girth)

# Afficher le data frame trié
print("Data frame A trié par Girth:")
print(A_ordered)

# 2) Renommer les row names : mean_tree -> mean, min_tree -> min, etc.
# Récupérer les noms des lignes
rownames(A_ordered) <- c("mean", "min", "max", "tree")

# Afficher le data frame avec les noms de lignes modifiés
print("Data frame A avec row names renommés:")
print(A_ordered)



```


```{r empty df}
# link1: R exercise
# Exercise 8: Creating an empty data frame with column types
df <- data.frame(Ints = integer(), Logicals = logical(), Doubles = double(), Characters = character())
str(df)


```


```{r duplicate items}
# link1: R exercise
# Exercise 9: Display,detect duplicate item and display rest item 
# Charger la bibliothèque dplyr
library(dplyr)

# Créer le data frame XY
XY <- data.frame(
  X = c(1, 2, 3, 1, 4, 5, 2),
  Y = c(0, 3, 2, 0, 5, 9, 3)
)

# Afficher le data frame XY
print("Data frame XY:")
print(XY)

# 1) Identifier les lignes dupliquées
duplicated_elements <- duplicated(XY)
print("Duplicated elements (TRUE indique les lignes dupliquées):")
print(duplicated_elements)

# Afficher les lignes dupliquées
print("Lignes dupliquées:")
print(XY[duplicated_elements, ])

# 2) Garder uniquement les lignes uniques
XY_unique <- distinct(XY)

# Afficher le data frame unique
print("Data frame XY avec uniquement les lignes uniques:")
print(XY_unique)



```


```{r sort_runtime}
# link1: R exercise
# Exercise 10:
library(dplyr)
library(tidyr)

# a) Utiliser le dataset 'Titanic' et le convertir en data frame
data("Titanic")
df_titanic <- as.data.frame(Titanic)

# Vérifier la classe
print(class(df_titanic))

# Afficher les premières lignes du dataset Titanic
print(head(df_titanic))

# b) Définir un data frame avec les conditions spécifiées
# Filtrer pour Class == "1st" et Survived == "No"
df_filtered <- df_titanic %>%
  filter(Class == "1st" & Survived == "No") %>%
  select(Sex, Age, Freq)

# Afficher le data frame résultant
print("Data frame avec Class = '1st' et Survived = 'No':")
print(df_filtered)

```


```{r sort_runtime}
#Test
data(mtcars)
head(mtcars)
?mtcars
```


```{r output}
# R Prog.
#Link 2: Exercice1: X output
X <- c(22, 3, 7, NA, NA, 67)
length(X)

```


```{r sort_runtime}
# R Prog.
#Link 2: Exercice 2: Removing all occurrences of NA in X.
#a
X <- c(22, 3, 7, NA, NA, 67)
 X[!is.na(X)]

```


```{r sort_runtime}
# R Prog.
#Link 2:Exercice3: replace all occurrences of NA with 11?
#b.
Y<- c(1,3,12,NA,33,7,NA,21)
Y[is.na(Y)]= 11

```


```{r sort_runtime}
# R Prog.
#Link 2:Exercice 4: Count the number of occurrences of NA in X
X <- c(34,33,65,37,89,NA,43,NA,11,NA,23,NA)
#b 
sum(is.na(X))

```


```{r rtn_missing}
# R Prog.
#Link 2: Exercise 5:  return TRUE for value of W missing in the vector.                           
 
W <- c (11, 3, 5, NA, 6)
any(is.na(W))
```

```{r rtn_missing}
# return TRUE for value of W missing in the vector.
# R Prog.
#Link 2: Exercise 6:  return TRUE for value of W missing in the vector.                          
data(Orange)
head(Orange)
Orange$age[Orange$age == 118] <- NA
 head(Orange)
```

```{r by_NA}
# return TRUE for value of W missing in the vector.
# R Prog.
#Link 2: Exercise 5:  return TRUE for value of W missing in the vector.                           
 
W <- c (11, 3, 5, NA, 6)
any(is.na(W))
```

```{r mean A}
# return TRUE for value of W missing in the vector.
# R Prog.
#Link 2: Exercise 7: calculate the mean of A without the missing value.             
 
A <- c (33, 21, 12, NA, 7, 8)
any(is.na(W))
mean(A, na.rm = TRUE)
```


```{r display}
# return TRUE for value of W missing in the vector.
# R Prog.
#Link 2: Exercise 8:Display all rows with missing values in X 
c1 <- c(1,2,3,NA) 
c2 <- c(2,4,6,89) 
c3 <- c(45,NA,66,101)  
X <- rbind (c1,c2,c3, deparse.level=1)
X[rowSums(is.na(X)) > 0, ]

```


```{r rows remove}
# return TRUE for value of W missing in the vector.
# R Prog.
#Link 2: Exercise 9:frame which removes all rows with NA values in Name column
df <- data.frame (Name = c(NA, "Joseph", "Martin", NA, "Andrea"), Sales = c(15, 18, 21, 56, 60), Price = c(34, 52, 21, 44, 20), stringsAsFactors = FALSE)
df
df <- df[!is.na(df$Name), ]
df
```


```{r NA rows}
# return TRUE for value of W missing in the vector.
# R Prog.
#Link 2: Exercise 10: Remove all rows with NA values:  
 
df <- na.omit(df)
df
```

#link3.Exercise 1: Load required packages and data.
```{r }
# Load necessary libraries

library(dplyr)
install.packages("AER")
library(AER)

# Load the Fertility dataset
data("Fertility")

# Glimpse at the data
glimpse(Fertility)


```

# link3.Exercise 2: Select rows 35 to 50 and display age and work columns
```{r }

library(dplyr)

Fertility %>%
  slice(35:50) %>%
  select(age, work)

```

#link3.Exercise 3: Select the last row in the dataset.
```{r }
library(dplyr)

Fertility %>%
  slice(n())  # Selects the last row

```

#link3.Exercise 4: Count how many women proceeded to have a third child.
```{r}
library(dplyr)
Fertility %>%
  filter(morekids == 1) %>%  # `morekids` column indicates if the woman had a third child
  count()

```

#link3.Exercise 5: Determine the most common gender combination for the first two children.
```{r }
library(dplyr)
Fertility %>%
  count(gender1, gender2) %>%  # Count combinations of `gender1` and `gender2`
  arrange(desc(n)) %>%        # Sort in descending order
  slice(1)                    # Select the most common combination


```

#link3.Exercise 6: Proportion of women working four weeks or less in 1979 by racial composition.
```{r }
library(dplyr)
Fertility %>%
  group_by(afam, hispanic, other) %>%
  summarise(mean(work <= 4))
  
```

#link3.Exercise 7: Proportion of women aged 22–24 with a boy as their firstborn.
```{r }
Fertility %>%
  filter(age >= 22, age <= 24) %>%          # Filter for women aged 22 to 24
  summarise(proportion_boys = mean(gender1 == "male", na.rm = TRUE))  # Calculate proportion of firstborn boys

```

#link3.Exercise 8: Add a new column for age squared.
```{r }
Fertility <- Fertility %>%
  mutate(age_squared = age^2)

# Display the updated dataset
glimpse(Fertility)

```

#link3.Exercise 9: Racial composition with the lowest proportion of boys for their firstborn.
```{r }
Fertility %>%
  group_by(afam, hispanic, other) %>%
  summarise(prop_boys_fb = mean(gender1 == "male"), n = n()) %>%
  arrange(prop_boys_fb)

```

#link3.Exercise 10: proportion of women who have a third child by gender combination of the first two children
```{r }
Fertility %>%
  group_by(gender1, gender2) %>%
  summarise(mean(morekids == "yes"))

```

#link4.Exercise 1:Create a scatterplot of mpg (x-axis) against drat (y-axis) and add a label to the x-axis.

```{r }
# Charger le dataset mtcars inclus dans R
data(mtcars)

# Créer un scatterplot de mpg (x-axis) contre drat (y-axis) avec une étiquette pour l'axe des x
plot(mtcars$mpg, mtcars$drat, xlab = "Miles per gallon", ylab = "Rear axle ratio", 
     main = "Scatterplot of mpg vs drat")

```

#link4.Exercise 2: a. Customize the y-axis label like we customized the x-axis in the previous exercise..
#b. Produce a plot customizing x and y axis, range and colours. Choose a range for x axis from 0 to 40, for y axis from 0 to 7, red colour and highlighted points.
```{r }
# Charger le dataset mtcars
data(mtcars)

# Créer un scatterplot avec une étiquette pour l'axe des y
plot(mtcars$mpg, mtcars$drat, ylab = "Rear axle ratio", xlab = "Miles per gallon")
# Créer un scatterplot personnalisé
plot(mtcars$mpg, mtcars$drat,
     xlab = "Miles per gallon", 
     ylab = "Rear axle ratio",
     xlim = c(0, 40),       # Plage pour l'axe des x
     ylim = c(0, 7),        # Plage pour l'axe des y
     col = "red",           # Couleur des points
     pch = 16)              # Type de point (16 pour des points pleins)

```

#link4.Exercise 3:a. plot(mpg,drat,main="Miles vs Rar")
#b. plot(mpg,drat,title="Miles vs Rar")
```{r }
# Ajouter un titre au graphique
plot(mtcars$mpg, mtcars$drat, 
     xlab = "Miles per gallon", 
     ylab = "Rear axle ratio", 
     main = "Miles vs Rar")

```

#link4.Exercise 4: a.Plot our data specifying that axes haven’t to be plotted.
b.Add axes, labels and text afterwards
```{r }
# Tracer les données sans axes
plot(mtcars$mpg, mtcars$drat, axes = FALSE, xlab = "", ylab = "")
# Ajouter les axes
axis(1, at = seq(0, 40, by = 5))  # Axe des x avec des marques de 5 en 5
axis(2, at = seq(0, 7, by = 1))   # Axe des y avec des marques de 1 en 1

# Ajouter les étiquettes et un titre
title(xlab = "Miles per gallon", ylab = "Rear axle ratio", main = "Scatterplot of mpg vs drat")

# Ajouter un texte au graphique
text(25, 5, "Highlighted point", col = "blue")  # Exemple d'ajout de texte


```

#Exercise 5 : Ajouter une légende à un graphique
# Correct response: b. plot(mpg, drat); legend()
```{r }
# Tracer le graphique
plot(mtcars$mpg, mtcars$drat, xlab = "Miles per gallon", ylab = "Rear axle ratio")

# Ajouter une légende
legend("topright", legend = "Data points", pch = 1, col = "black")

```

#Exercise 6a : Personnaliser la légende avec différents symboles, couleurs et positions

```{r }
# Tracer le graphique avec différents groupes
plot(mtcars$mpg, mtcars$drat, col = mtcars$cyl, pch = mtcars$gear, 
     xlab = "Miles per gallon", ylab = "Rear axle ratio")

# Ajouter une légende avec des symboles et couleurs personnalisés
legend("bottomleft", 
       legend = c("Group 1", "Group 2", "Group 3"), 
       col = c("red", "blue", "green"), 
       pch = c(1, 2, 3), 
       bg = "lightgrey")

```

#Exercise 6b : Insérer de nouvelles variables dans le graphique et personnaliser la légende

```{r }
# Créer un graphique avec deux groupes basés sur une nouvelle variable
plot(mtcars$mpg, mtcars$drat, col = ifelse(mtcars$hp > 150, "red", "blue"), pch = 16,
     xlab = "Miles per gallon", ylab = "Rear axle ratio")

# Ajouter une légende pour les nouvelles variables
legend("topright", 
       legend = c("High Horsepower", "Low Horsepower"), 
       col = c("red", "blue"), 
       pch = 16)

```

#Exercise 7a : Tracer deux variables à la fois en supprimant les axes et en les ajoutant après
```{r }
# Étape 1 : Tracer les données sans axes ni étiquettes
plot(mtcars$mpg, mtcars$drat, axes = FALSE, xlab = "", ylab = "")

# Étape 2 : Ajouter les axes et les étiquettes
axis(1, at = seq(10, 35, by = 5))  # Axe des x
axis(2, at = seq(2, 5, by = 1))    # Axe des y
title(xlab = "Miles per gallon", ylab = "Rear axle ratio", main = "Customized Plot")

#b : Ajouter une légende avec des couleurs et symboles pour chaque variable
# Tracer deux variables et personnaliser les points par groupe
plot(mtcars$mpg, mtcars$drat, col = mtcars$cyl, pch = mtcars$gear, 
     xlab = "Miles per gallon", ylab = "Rear axle ratio")

# Ajouter une légende dans la position top-right
legend("topright", 
       legend = c("Cyl: 4, Gear: 3", "Cyl: 6, Gear: 4", "Cyl: 8, Gear: 5"), 
       col = c("red", "blue", "green"), 
       pch = c(1, 2, 3))

```

#Link5: Replicating Plots – Boxplot Exercises
#Exercice 1 : Boxplot par défaut de Sepal.Width stratifié par Species
```{r }
# Boxplot par défaut
boxplot(Sepal.Width ~ Species, data = iris)

```

#Link5: Replicating Plots – Boxplot Exercises
#Exercice 2 : Changer la plage de l'axe y pour qu'elle commence à 2 et se termine à 4.5
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5))

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 3 : Supprimer les ticks et les étiquettes des axes
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), axes = FALSE)

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 4 : Ajouter des notches (entailles) pour représenter les intervalles de confiance autour de la médiane
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE)

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 5 : Augmenter la distance entre les boîtes
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE, space = 2)

```

#Link5: Replicating Plots – Boxplot Exercises
#Exercice 6 : Changer la couleur des bordures des boîtes en bleu
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE, border = "blue")

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 7 :
a. Changer la couleur des lignes médianes en rouge
b. Changer l'épaisseur des lignes médianes à 1
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE, border = "blue",
        medcol = "red", medlwd = 1)

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 8 :
a. Changer la couleur des points pour les valeurs aberrantes en rouge
b. Changer le symbole des points aberrants en "+"
c. Changer la taille des points aberrants à 0.8
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE, border = "blue",
        medcol = "red", medlwd = 1, outcol = "red", outpch = 3, outcex = 0.8)

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 9 :
a. Ajouter un titre au boxplot
b. Ajouter un label pour l'axe y
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE, border = "blue",
        medcol = "red", medlwd = 1, outcol = "red", outpch = 3, outcex = 0.8,
        main = "Boxplot: Sepal Width by Species", ylab = "Sepal Width (cm)")

```
#Link5: Replicating Plots – Boxplot Exercises
#Exercice 10 :
a. Ajouter un axe x semblable à celui de MATLAB
b. Ajouter un axe y semblable à celui de MATLAB
c. Ajouter des ticks de l'axe y de l'autre côté
```{r }
boxplot(Sepal.Width ~ Species, data = iris, ylim = c(2, 4.5), notch = TRUE, border = "blue",
        medcol = "red", medlwd = 1, outcol = "red", outpch = 3, outcex = 0.8,
        main = "Boxplot: Sepal Width by Species", ylab = "Sepal Width (cm)", axes = FALSE)

# Ajouter l'axe x
axis(1, at = 1:3, labels = levels(iris$Species), las = 1)

# Ajouter l'axe y
axis(2, at = seq(2, 4.5, by = 0.5), labels = format(as.character(seq(2, 4.5, by = 0.5)), drop0trailing = TRUE))

# Ajouter les ticks de l'axe y de l'autre côté
axis(4, at = seq(2, 4.5, by = 0.5), labels = FALSE)

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
